<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="styles.css">
    <title>LoopSense - Scalable color system for data visualization</title>
</head>
<body>

<h1>LoopSense - Scalable color system for data visualization</h1>

<div id="container" data-controller="color"></div>

<!-- Include Stimulus.js from a CDN -->
<script src="https://unpkg.com/@hotwired/stimulus/dist/stimulus.umd.js"></script>
<script>
    (() => {
        const application = Stimulus.Application.start();

        application.register("color", class extends Stimulus.Controller {

            connect() {
                // Array of objects containing the base hex codes and their associated device types.
                this.baseColors = [
                    { hex: '#003F5C', deviceType: 'Pressure Controller' },
                    { hex: '#016C59', deviceType: 'Sensor' },
                    { hex: '#7A5195', deviceType: 'Pumping Station' },
                    { hex: '#BC5090', deviceType: 'Flow meter' },
                    { hex: '#EF5675', deviceType: 'Mesh/Repeater' },
                    { hex: '#FFA600', deviceType: 'Mesh/Gateway' },
                ];
                this.numberOfVariations = 250; 
                this.displayColors();
            }

            // Display colors on the page
            displayColors() {
                this.baseColors.forEach(baseColor => {
                    const deviceSection = document.createElement('div');
                    deviceSection.classList.add('device-section');

                    const deviceTitle = document.createElement('div');
                    deviceTitle.classList.add('device-title');
                    deviceTitle.textContent = baseColor.deviceType;
                    deviceSection.appendChild(deviceTitle);

                    const colorGrid = document.createElement('div');
                    colorGrid.classList.add('color-grid');

                    const colors = this.generateColorVariations(baseColor.hex, this.numberOfVariations);
                    colors.forEach(color => {
                        const colorBox = document.createElement('div');
                        colorBox.classList.add('color-box');
                        colorBox.style.backgroundColor = color;
                        colorBox.textContent = color;
                        // Adjust text color for better readability
                        const hsl = this.hexToHSL(color);
                        colorBox.style.color = hsl.l > 50 ? '#000' : '#fff';
                        
                        colorGrid.appendChild(colorBox);
                    });

                    deviceSection.appendChild(colorGrid);
                    this.element.appendChild(deviceSection);
                });
            }

            // Method to generate color variations
            generateColorVariations(baseHex, count) {
                const hsl = this.hexToHSL(baseHex);
                const colors = [];
                const lightnessIncrement = (100 - hsl.l) / (count - 1);

                for (let i = 0; i < count; i++) {
                    const newLightness = hsl.l + i * lightnessIncrement;
                    const newHex = this.hslToHex(hsl.h, hsl.s, newLightness);
                    colors.push(newHex);
                }
                return colors;
            }

            // Helper method to convert HEX to HSL
            hexToHSL(H) {
                let r = 0, g = 0, b = 0;
                if (H.length == 4) {
                    r = "0x" + H[1] + H[1];
                    g = "0x" + H[2] + H[2];
                    b = "0x" + H[3] + H[3];
                } else if (H.length == 7) {
                    r = "0x" + H[1] + H[2];
                    g = "0x" + H[3] + H[4];
                    b = "0x" + H[5] + H[6];
                }
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max == min) {
                    h = s = 0; // Achromatic
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r:
                            h = ((g - b) / d + (g < b ? 6 : 0));
                            break;
                        case g:
                            h = ((b - r) / d + 2);
                            break;
                        case b:
                            h = ((r - g) / d + 4);
                            break;
                    }
                    h /= 6;
                }
                return { h: h * 360, s: s * 100, l: l * 100 };
            }

            // Helper method to convert HSL to HEX
            hslToHex(h, s, l) {
                s /= 100;
                l /= 100;

                const k = n => (n + h / 30) % 12;
                const a = s * Math.min(l, 1 - l);
                const f = n => l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);

                const rgb = [f(0), f(8), f(4)].map(x => Math.round(x * 255));
                return '#' + rgb.map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }
        });
    })();
</script>

</body>
</html>